// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'active_streams.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$StreamsData {
  String get episodeTitle => throw _privateConstructorUsedError;
  int get releaseYear => throw _privateConstructorUsedError;
  String get remoteURL => throw _privateConstructorUsedError;
  MediaFormat get mediaType => throw _privateConstructorUsedError;
  String get userName => throw _privateConstructorUsedError;
  int get seasonNum => throw _privateConstructorUsedError;
  int get episodeNum => throw _privateConstructorUsedError;
  String get masterName => throw _privateConstructorUsedError;
  String get id => throw _privateConstructorUsedError;
  String get imagePath => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StreamsDataCopyWith<StreamsData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StreamsDataCopyWith<$Res> {
  factory $StreamsDataCopyWith(
          StreamsData value, $Res Function(StreamsData) then) =
      _$StreamsDataCopyWithImpl<$Res, StreamsData>;
  @useResult
  $Res call(
      {String episodeTitle,
      int releaseYear,
      String remoteURL,
      MediaFormat mediaType,
      String userName,
      int seasonNum,
      int episodeNum,
      String masterName,
      String id,
      String imagePath});
}

/// @nodoc
class _$StreamsDataCopyWithImpl<$Res, $Val extends StreamsData>
    implements $StreamsDataCopyWith<$Res> {
  _$StreamsDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? episodeTitle = null,
    Object? releaseYear = null,
    Object? remoteURL = null,
    Object? mediaType = null,
    Object? userName = null,
    Object? seasonNum = null,
    Object? episodeNum = null,
    Object? masterName = null,
    Object? id = null,
    Object? imagePath = null,
  }) {
    return _then(_value.copyWith(
      episodeTitle: null == episodeTitle
          ? _value.episodeTitle
          : episodeTitle // ignore: cast_nullable_to_non_nullable
              as String,
      releaseYear: null == releaseYear
          ? _value.releaseYear
          : releaseYear // ignore: cast_nullable_to_non_nullable
              as int,
      remoteURL: null == remoteURL
          ? _value.remoteURL
          : remoteURL // ignore: cast_nullable_to_non_nullable
              as String,
      mediaType: null == mediaType
          ? _value.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as MediaFormat,
      userName: null == userName
          ? _value.userName
          : userName // ignore: cast_nullable_to_non_nullable
              as String,
      seasonNum: null == seasonNum
          ? _value.seasonNum
          : seasonNum // ignore: cast_nullable_to_non_nullable
              as int,
      episodeNum: null == episodeNum
          ? _value.episodeNum
          : episodeNum // ignore: cast_nullable_to_non_nullable
              as int,
      masterName: null == masterName
          ? _value.masterName
          : masterName // ignore: cast_nullable_to_non_nullable
              as String,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      imagePath: null == imagePath
          ? _value.imagePath
          : imagePath // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_StreamsDataCopyWith<$Res>
    implements $StreamsDataCopyWith<$Res> {
  factory _$$_StreamsDataCopyWith(
          _$_StreamsData value, $Res Function(_$_StreamsData) then) =
      __$$_StreamsDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String episodeTitle,
      int releaseYear,
      String remoteURL,
      MediaFormat mediaType,
      String userName,
      int seasonNum,
      int episodeNum,
      String masterName,
      String id,
      String imagePath});
}

/// @nodoc
class __$$_StreamsDataCopyWithImpl<$Res>
    extends _$StreamsDataCopyWithImpl<$Res, _$_StreamsData>
    implements _$$_StreamsDataCopyWith<$Res> {
  __$$_StreamsDataCopyWithImpl(
      _$_StreamsData _value, $Res Function(_$_StreamsData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? episodeTitle = null,
    Object? releaseYear = null,
    Object? remoteURL = null,
    Object? mediaType = null,
    Object? userName = null,
    Object? seasonNum = null,
    Object? episodeNum = null,
    Object? masterName = null,
    Object? id = null,
    Object? imagePath = null,
  }) {
    return _then(_$_StreamsData(
      episodeTitle: null == episodeTitle
          ? _value.episodeTitle
          : episodeTitle // ignore: cast_nullable_to_non_nullable
              as String,
      releaseYear: null == releaseYear
          ? _value.releaseYear
          : releaseYear // ignore: cast_nullable_to_non_nullable
              as int,
      remoteURL: null == remoteURL
          ? _value.remoteURL
          : remoteURL // ignore: cast_nullable_to_non_nullable
              as String,
      mediaType: null == mediaType
          ? _value.mediaType
          : mediaType // ignore: cast_nullable_to_non_nullable
              as MediaFormat,
      userName: null == userName
          ? _value.userName
          : userName // ignore: cast_nullable_to_non_nullable
              as String,
      seasonNum: null == seasonNum
          ? _value.seasonNum
          : seasonNum // ignore: cast_nullable_to_non_nullable
              as int,
      episodeNum: null == episodeNum
          ? _value.episodeNum
          : episodeNum // ignore: cast_nullable_to_non_nullable
              as int,
      masterName: null == masterName
          ? _value.masterName
          : masterName // ignore: cast_nullable_to_non_nullable
              as String,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      imagePath: null == imagePath
          ? _value.imagePath
          : imagePath // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_StreamsData with DiagnosticableTreeMixin implements _StreamsData {
  const _$_StreamsData(
      {required this.episodeTitle,
      required this.releaseYear,
      required this.remoteURL,
      required this.mediaType,
      required this.userName,
      required this.seasonNum,
      required this.episodeNum,
      required this.masterName,
      required this.id,
      required this.imagePath});

  @override
  final String episodeTitle;
  @override
  final int releaseYear;
  @override
  final String remoteURL;
  @override
  final MediaFormat mediaType;
  @override
  final String userName;
  @override
  final int seasonNum;
  @override
  final int episodeNum;
  @override
  final String masterName;
  @override
  final String id;
  @override
  final String imagePath;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StreamsData(episodeTitle: $episodeTitle, releaseYear: $releaseYear, remoteURL: $remoteURL, mediaType: $mediaType, userName: $userName, seasonNum: $seasonNum, episodeNum: $episodeNum, masterName: $masterName, id: $id, imagePath: $imagePath)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'StreamsData'))
      ..add(DiagnosticsProperty('episodeTitle', episodeTitle))
      ..add(DiagnosticsProperty('releaseYear', releaseYear))
      ..add(DiagnosticsProperty('remoteURL', remoteURL))
      ..add(DiagnosticsProperty('mediaType', mediaType))
      ..add(DiagnosticsProperty('userName', userName))
      ..add(DiagnosticsProperty('seasonNum', seasonNum))
      ..add(DiagnosticsProperty('episodeNum', episodeNum))
      ..add(DiagnosticsProperty('masterName', masterName))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('imagePath', imagePath));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StreamsData &&
            (identical(other.episodeTitle, episodeTitle) ||
                other.episodeTitle == episodeTitle) &&
            (identical(other.releaseYear, releaseYear) ||
                other.releaseYear == releaseYear) &&
            (identical(other.remoteURL, remoteURL) ||
                other.remoteURL == remoteURL) &&
            (identical(other.mediaType, mediaType) ||
                other.mediaType == mediaType) &&
            (identical(other.userName, userName) ||
                other.userName == userName) &&
            (identical(other.seasonNum, seasonNum) ||
                other.seasonNum == seasonNum) &&
            (identical(other.episodeNum, episodeNum) ||
                other.episodeNum == episodeNum) &&
            (identical(other.masterName, masterName) ||
                other.masterName == masterName) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.imagePath, imagePath) ||
                other.imagePath == imagePath));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      episodeTitle,
      releaseYear,
      remoteURL,
      mediaType,
      userName,
      seasonNum,
      episodeNum,
      masterName,
      id,
      imagePath);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StreamsDataCopyWith<_$_StreamsData> get copyWith =>
      __$$_StreamsDataCopyWithImpl<_$_StreamsData>(this, _$identity);
}

abstract class _StreamsData implements StreamsData {
  const factory _StreamsData(
      {required final String episodeTitle,
      required final int releaseYear,
      required final String remoteURL,
      required final MediaFormat mediaType,
      required final String userName,
      required final int seasonNum,
      required final int episodeNum,
      required final String masterName,
      required final String id,
      required final String imagePath}) = _$_StreamsData;

  @override
  String get episodeTitle;
  @override
  int get releaseYear;
  @override
  String get remoteURL;
  @override
  MediaFormat get mediaType;
  @override
  String get userName;
  @override
  int get seasonNum;
  @override
  int get episodeNum;
  @override
  String get masterName;
  @override
  String get id;
  @override
  String get imagePath;
  @override
  @JsonKey(ignore: true)
  _$$_StreamsDataCopyWith<_$_StreamsData> get copyWith =>
      throw _privateConstructorUsedError;
}
